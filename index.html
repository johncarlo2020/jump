<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Mouse Runner</title>
    <style>
        @font-face {
            font-family: 'Brevia';
            src: url('assets/font/09BREVIA-BOLD.OTF') format('opentype');
            font-weight: 700;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Brevia', 'Arial', sans-serif;
            font-weight: 700;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: #87CEEB;
            cursor: none;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        #logo {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 144px;
            height: 144px;
            pointer-events: none;
        }

        #timeDisplay {
            position: absolute;
            top: 30px;
            left: 200px;
            background: #1B4F91;
            color: white;
            padding: 18px 54px;
            border-radius: 18px;
            font-size: 38px;
            font-weight: bold;
            text-shadow: none;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #timeDisplay::before {
            content: '⏳';
            font-size: 32px;
        }

        #totalDisplay {
            position: absolute;
            top: 30px;
            right: 30px;
            background: #1B4F91;
            color: white;
            padding: 18px 54px;
            border-radius: 18px;
            font-size: 38px;
            font-weight: bold;
            text-shadow: none;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #totalDisplay::before {
            content: '✨';
            font-size: 32px;
        }

        #timeRemaining {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            display: none;
        }

        #timeRemaining.warning {
            color: #ff6b6b;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 200px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
            display: none;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/page/score.webp');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #gameOver h1 {
            position: absolute;
            top:50%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 180px;
            font-weight: 900;
            color: white;
            margin: 0;
            -webkit-text-stroke: 12px #1B4F91;
            text-stroke: 12px #1B4F91;
            paint-order: stroke fill;
            letter-spacing: -5px;
        }

        #scoreDetails {
            position: absolute;
            top: 50%;
            width: 80%;
            max-width: 600px;
            display: flex;
            justify-content: space-around;
            color: #1B4F91;
            font-weight: bold;
        }

        .scoreItem {
            text-align: center;
        }

        .scoreLabel {
            display: none;
        }

        .scoreValue {
            font-size: 48px;
            font-weight: bold;
            color: #1B4F91;
        }

        #gameOver button {
            position: absolute;
            bottom: 150px;
            padding: 30px 120px;
            font-size: 64px;
            background: #29b5e8;
            color: white;
            border: 6px solid white;
            border-radius: 80px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #gameOver button:hover {
            background: #1a9dd1;
            transform: scale(1.05);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        }

        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 60%;
        }

        #welcomeScreen button {
            padding: 30px 120px;
            font-size: 64px;
            background: #29b5e8;
            color: white;
            border: 6px solid white;
            border-radius: 80px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
        }

        #welcomeScreen button:hover {
            background: #1a9dd1;
            transform: scale(1.05);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        }

        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 270px;

        }

        #instructionText {
            font-size: 68px;
            font-weight: 900;
            color: white;
            -webkit-text-stroke: 8px #1B4F91;
            text-stroke: 8px #1B4F91;
            paint-order: stroke fill;
            letter-spacing: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: lowercase;
            transition: transform 0.3s ease;
        }

        #instructionText:hover {
            transform: scale(1.05);
        }

        #instructionText img {
            height: 68px;
            margin: 0 20px;
            vertical-align: middle;
        }

        #settings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            display: none;
        }

        #settings::-webkit-scrollbar {
            width: 10px;
        }

        #settings::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        #settings::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 5px;
        }

        #settings::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        #settings h2 {
            font-size: 30px;
            margin-bottom: 20px;
            color: #667eea;
            text-align: center;
        }

        .setting-group {
            margin: 15px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .setting-group label {
            display: block;
            font-size: 15px;
            margin-bottom: 8px;
            color: #a8b3cf;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .setting-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .setting-value {
            display: inline-block;
            float: right;
            font-weight: bold;
            color: #667eea;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .preset-buttons button {
            flex: 1;
            padding: 10px;
            font-size: 15px;
            background: rgba(102, 126, 234, 0.3);
            color: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-buttons button:hover {
            background: #667eea;
            transform: translateY(-2px);
        }

        .preset-buttons button.active {
            background: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }

        #settings .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        } 

        #settings .button-group button {
            flex: 1;
            padding: 12px;
            font-size: 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #settings .button-group button:hover {
            background: #764ba2;
        }

        #settings .button-group button.secondary {
            background: rgba(255, 255, 255, 0.1);
        }

        #settings .button-group button.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .settings-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            padding: 15px 30px;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }

        .settings-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .point-popup {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            color: #29b5e8;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8), 
                         0 0 20px rgba(41, 181, 232, 0.6);
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s ease-out forwards;
            -webkit-text-stroke: 2px #1B4F91;
            text-stroke: 2px #1B4F91;
        }

        .point-popup.negative {
            color: #FF0000;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8), 
                         0 0 20px rgba(255, 0, 0, 0.6);
            -webkit-text-stroke: 2px #8B0000;
            text-stroke: 2px #8B0000;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1.3);
                opacity: 0;
            }
        }

        @keyframes shake {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-3px, 0, 0); }
            75% { transform: translate3d(3px, 0, 0); }
        }

        .shake {
            animation: shake 0.2s ease-in-out;
            will-change: transform;
        }

        #gameCanvas.red-border {
            box-shadow: inset 0 0 0 40px rgba(255, 0, 0, 0.7);
            filter: brightness(0.8) saturate(2) hue-rotate(-10deg);
            transition: all 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1080" height="1920"></canvas>
        
        <img id="logo" src="assets/logo.webp" alt="Logo">
        
        <div id="timeDisplay">
            MASA: <span id="timeLeft">25</span>
        </div>

        <div id="totalDisplay">
            JUMLAH: <span id="score">0</span>
        </div>

        <div id="ui" style="display: none;">
            <div>Skor: <span id="scoreOld">0</span></div>
            <div>High Score: <span id="highScore">0</span></div>
        </div>

        <div id="timeRemaining">
            <div>Time: <span id="timeLeftOld">25</span>s</div>
        </div>

        <div id="countdown"></div>

        <div id="welcomeScreen">
            <button id="welcomeBtn">MULA!</button>
        </div>

        <div id="instructions">
            <div id="instructionText" onclick="startGame()">
                Tekan <img src="assets/logo.webp" alt="Dutch Lady"> untuk mulakan!
            </div>
        </div>

        <a href="settings.html" class="settings-btn" style="text-decoration: none; display: none;">⚙️ Settings</a>

        <div id="gameOver">
            <h1 id="scoreNumber">100</h1>
            <button id="restartBtn">SELESAI</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        
        // Disable image smoothing for better performance
        ctx.imageSmoothingEnabled = false;

        // UI elements
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverScreen = document.getElementById('gameOver');
        const welcomeScreen = document.getElementById('welcomeScreen');
        const instructionsScreen = document.getElementById('instructions');
        const welcomeBtn = document.getElementById('welcomeBtn');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const timeLeftElement = document.getElementById('timeLeft');
        const timeRemainingDiv = document.getElementById('timeRemaining');
        const countdownElement = document.getElementById('countdown');

        // Set background images
        welcomeScreen.style.backgroundImage = 'url(assets/page/welcome.webp)';
        instructionsScreen.style.backgroundImage = 'url(assets/page/instruction.webp)';

        // Game state
        let gameRunning = false;
        let score = 0;
        let collectedItems = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        highScoreElement.textContent = highScore;

        // Load sound effects
        const sounds = {
            background: new Audio('assets/SOUNDTRACK/bg.mp3'),
            bomb: new Audio('assets/SOUNDTRACK/bomb effects.mp3'),
            collect: new Audio('assets/SOUNDTRACK/collect bird nest.mp3'),
            completed: new Audio('assets/SOUNDTRACK/completed.mp3'),
            countdown: new Audio('assets/SOUNDTRACK/countdownsound.mp3'),
            gameOver: new Audio('assets/SOUNDTRACK/game over .mp3'),
            gameWon: new Audio('assets/SOUNDTRACK/game won.mp3'),
            buzzer: new Audio('assets/SOUNDTRACK/long-buzzer.mp3'),
            select: new Audio('assets/SOUNDTRACK/select-sound.mp3'),
            wrongItem: new Audio('assets/SOUNDTRACK/wrong item.mp3')
        };

        // Configure background music to loop
        sounds.background.loop = true;
        sounds.background.volume = 0.3;

        // Helper function to play sound
        function playSound(soundName) {
            if (sounds[soundName]) {
                sounds[soundName].currentTime = 0;
                sounds[soundName].play().catch(e => console.log('Audio play failed:', e));
            }
        }

        // Timer variables
        const GAME_DURATION = 25; // seconds
        let gameTimer = GAME_DURATION;
        let gameStartTime = 0;
        
        // Debug mode
        let debugMode = false; // Set to true to show collision boxes

        // Game settings with defaults (Medium difficulty)
        let gameSettings = {
            initialSpeed: 7.2,
            maxSpeed: 21.6,
            jumpForce: 20,
            gravity: 0.5,
            jumpSensitivity: 7,
            fallSensitivity: 5,
            obstacleInterval: 120,
            fallMultiplier: 2.5,
            obstacleSpawnRate: 10,
            positiveCollectibleRate: 91,
            dropRate: 80
        };

        // Difficulty presets
        const difficultyPresets = {
            easy: {
                initialSpeed: 4.8,
                maxSpeed: 14.4,
                jumpForce: 19,
                gravity: 0.45,
                jumpSensitivity: 8,
                fallSensitivity: 6,
                obstacleInterval: 150,
                fallMultiplier: 2,
                obstacleSpawnRate: 5,
                positiveCollectibleRate: 95,
                dropRate: 70
            },
            medium: {
                initialSpeed: 7.2,
                maxSpeed: 21.6,
                jumpForce: 20,
                gravity: 0.5,
                jumpSensitivity: 7,
                fallSensitivity: 5,
                obstacleInterval: 120,
                fallMultiplier: 2.5,
                obstacleSpawnRate: 10,
                positiveCollectibleRate: 91,
                dropRate: 80
            },
            hard: {
                initialSpeed: 9.6,
                maxSpeed: 28.8,
                jumpForce: 22,
                gravity: 0.6,
                jumpSensitivity: 5,
                fallSensitivity: 4,
                obstacleInterval: 100,
                fallMultiplier: 3,
                obstacleSpawnRate: 15,
                positiveCollectibleRate: 85,
                dropRate: 70
            }
        };

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('gameSettings');
            if (saved) {
                gameSettings = JSON.parse(saved);
            }
            applySettingsToUI();
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('gameSettings', JSON.stringify(gameSettings));
        }

        // Apply settings to UI sliders (removed - now in separate settings page)
        function applySettingsToUI() {
            // Settings UI is now on a separate page
        }

        // Update obstacle frequency label (removed - now in separate settings page)
        function updateObstacleFreqLabel(value) {
            // Not needed in main game
        }

        // Apply preset difficulty
        function applyPreset(preset) {
            gameSettings = { ...difficultyPresets[preset] };
            saveSettings();
        }

        // Initialize settings
        loadSettings();

        // Load character sprites
        const runningSprite = new Image();
        runningSprite.src = 'assets/running.webp';
        const jumpingSprite = new Image();
        jumpingSprite.src = 'assets/jumping.webp';
        
        // Load obstacle sprites
        const obstacleImages = [];
        const obstacleFiles = ['0014_rock01.webp', '0014_rock02.png', '0015_cube.webp'];
        
        obstacleFiles.forEach(file => {
            const img = new Image();
            img.src = 'assets/obstacles/' + file;
            obstacleImages.push(img);
        });
        
        // Load point collectible images
        const collectibleImages = {};
        collectibleImages.bone = new Image();
        collectibleImages.bone.src = 'assets/points/bone.webp';
        collectibleImages.arm = new Image();
        collectibleImages.arm.src = 'assets/points/arm.webp';
        collectibleImages.bomb = new Image();
        collectibleImages.bomb.src = 'assets/points/bomb.webp';
        
        let imagesLoaded = 0;
        const totalImages = 2 + obstacleFiles.length + 3; // +3 for collectibles
        
        runningSprite.onload = () => {
            imagesLoaded++;
            checkImagesLoaded();
        };
        
        jumpingSprite.onload = () => {
            imagesLoaded++;
            checkImagesLoaded();
        };
        
        obstacleImages.forEach(img => {
            img.onload = () => {
                imagesLoaded++;
                checkImagesLoaded();
            };
        });
        
        collectibleImages.bone.onload = () => { imagesLoaded++; checkImagesLoaded(); };
        collectibleImages.arm.onload = () => { imagesLoaded++; checkImagesLoaded(); };
        collectibleImages.bomb.onload = () => { imagesLoaded++; checkImagesLoaded(); };
        
        let assetsReady = false;
        function checkImagesLoaded() {
            if (imagesLoaded === totalImages) {
                assetsReady = true;
                // Create floor pattern
                if (floorImage.complete && floorImage.naturalWidth > 0) {
                    floorPattern = ctx.createPattern(floorImage, 'repeat');
                }
            }
        }

        // Mouse tracking
        let lastMouseY = 0;
        let currentMouseY = 0;

        // Player object
        const player = {
            x: 100,
            y: 0,
            width: 240,
            height: 300,
            velocityY: 0,
            gravity: 0.2,
            jumpForce: -180,
            fastFallMultiplier: 2.5,
            isJumping: false,
            isFastFalling: false,
            color: '#ff6b6b'
        };

        // Apply current settings to player
        function applySettingsToPlayer() {
            player.gravity = gameSettings.gravity;
            player.jumpForce = -gameSettings.jumpForce;
            player.fastFallMultiplier = gameSettings.fallMultiplier;
        }

        // Apply settings initially
        applySettingsToPlayer();

        // Ground - positioned so floor occupies 33% of screen height
        const groundY = canvas.height * 0.67; // 67% from top = 33% for floor
        player.y = groundY - player.height;

        // Load floor image
        const floorImage = new Image();
        floorImage.src = 'assets/floor.webp';
        let floorPattern = null;
        
        floorImage.onload = function() {
            floorPattern = ctx.createPattern(floorImage, 'repeat');
        };

        // Show countdown
        function showCountdown(number) {
            return new Promise((resolve) => {
                countdownElement.textContent = number === 0 ? 'JOM!' : number;
                countdownElement.style.display = 'block';
                playSound('countdown');
                
                // Force reflow to restart animation
                countdownElement.style.animation = 'none';
                countdownElement.offsetHeight; // Trigger reflow
                countdownElement.style.animation = 'countdownPulse 1s ease-in-out';
                
                setTimeout(() => {
                    if (number === 0) {
                        countdownElement.style.display = 'none';
                    }
                    resolve();
                }, 1000);
            });
        }

        // Show point collection popup
        function showPointPopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = 'point-popup';
            
            // Style based on positive or negative points
            if (points < 0) {
                popup.classList.add('negative');
                popup.textContent = points; // Already has minus sign
            } else {
                popup.textContent = '+' + points;
            }
            
            // Get canvas position and scale
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            
            // Convert canvas coordinates to screen coordinates
            const screenX = rect.left + (x * scaleX);
            const screenY = rect.top + (y * scaleY);
            
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            document.getElementById('gameContainer').appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1000);
        }

        // Obstacles array
        let obstacles = [];
        let obstacleTimer = 0;
        let obstacleInterval = 120; // Frames between obstacles

        // Game speed
        let gameSpeed = gameSettings.initialSpeed;
        let maxSpeed = gameSettings.maxSpeed;
        const speedIncrement = 0.0016;

        // Performance optimization
        let lastTime = performance.now();

        // Handle tab visibility to prevent issues
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && gameRunning) {
                // Reset timing when returning to tab
                lastTime = performance.now();
            }
        });

        // Background scroll
        let scrollOffset = 0;
        let floorScrollOffset = 0;
        let cloudScrollOffset = 0;

        // Remove console.log statements from game loop
        window.addEventListener('mousemove', (e) => {
            currentMouseY = e.clientY;
            
            if (!gameRunning) return;

            const deltaY = lastMouseY - currentMouseY;

            // Jump detection: mouse moved UP by threshold (more sensitive)
            if (deltaY > 3 && !player.isJumping) {
                jump();
            }

            // Fast fall detection: mouse moved DOWN
            if (deltaY < -gameSettings.fallSensitivity && player.isJumping) {
                player.isFastFalling = true;
            } else {
                player.isFastFalling = false;
            }

            lastMouseY = currentMouseY;
        });

        // Initialize last mouse position
        window.addEventListener('mousemove', (e) => {
            if (lastMouseY === 0) {
                lastMouseY = e.clientY;
            }
        }, { once: true });

        // Jump function
        function jump() {
            // More forgiving ground check - allow jump if close to ground or already on ground
            const distanceFromGround = (groundY - player.height) - player.y;
            // Extended range to prevent delay after getting hit
            if (distanceFromGround >= -30 && distanceFromGround <= 10) {
                player.velocityY = player.jumpForce;
                player.isJumping = true;
                playSound('select');
            }
        }

        // Create obstacle
        function createObstacle() {
            const rand = Math.random() * 100;
            const obstacleRate = gameSettings.obstacleSpawnRate || 20;
            
            // Use dynamic obstacle spawn rate from settings
            if (rand < obstacleRate) {
                // Ground obstacle (challenging but jumpable)
                let obstacle = {
                    x: canvas.width,
                    width: 60 + Math.random() * 48,  // 60-108 pixels wide
                    height: 84 + Math.random() * 60,  // 84-144 pixels tall
                    color: '#2c3e50',
                    type: 'ground',
                    imageIndex: Math.floor(Math.random() * obstacleImages.length)
                };
                obstacle.y = groundY - obstacle.height;
                obstacles.push(obstacle);
            } else {
                // Collectible points - use dynamic positive rate from settings
                const positiveRate = gameSettings.positiveCollectibleRate || 91;
                const isPositive = Math.random() * 100 < positiveRate;
                
                // Create weighted array based on positive rate
                let collectibleTypes;
                if (isPositive) {
                    collectibleTypes = ['bone', 'arm'];
                } else {
                    collectibleTypes = ['bomb'];
                }
                const pointValues = { bone: 5, arm: 5, bomb: -2 };
                const randomType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
                
                let collectible = {
                    x: canvas.width,
                    width: 100,
                    height: 100,
                    type: 'collectible',
                    collected: false,
                    collectibleType: randomType,
                    pointValue: pointValues[randomType]
                };
                // Position at three heights: ground, middle, or top (highest jump peak)
                const heightRand = Math.random();
                if (heightRand < 0.33) {
                    // Ground level
                    collectible.y = groundY - collectible.height;
                } else if (heightRand < 0.66) {
                    // Middle height (mid-jump)
                    collectible.y = groundY - 200 - collectible.height;
                } else {
                    // Top height (peak of jump - highest reachable point)
                    collectible.y = groundY - 350 - collectible.height;
                }
                obstacles.push(collectible);
            }
        }

        // Update player
        function updatePlayer() {
            // Apply gravity
            const gravityForce = player.isFastFalling ? 
                player.gravity * player.fastFallMultiplier : 
                player.gravity;
            
            player.velocityY += gravityForce;

            // Update position
            player.y += player.velocityY;

            // Ground collision - with more forgiving check
            const groundLevel = groundY - player.height;
            if (player.y >= groundLevel) {
                player.y = groundLevel;
                player.velocityY = 0;
                player.isJumping = false;
                player.isFastFalling = false;
            }

            // Ceiling collision
            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }
        }

        // Update obstacles
        function updateObstacles(deltaTime, effectiveSpeed = gameSpeed) {
            obstacleTimer++;

            // Use drop rate from settings
            const currentDropRate = gameSettings.dropRate || obstacleInterval;
            
            // Create new obstacle - limit total for performance
            if (obstacleTimer > currentDropRate && obstacles.length < 12) {
                createObstacle();
                obstacleTimer = 0;
                // Decrease interval slightly, min 85 frames
                obstacleInterval = Math.max(85, obstacleInterval - 0.2);
            }

            // Move obstacles at consistent speed
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.x -= effectiveSpeed;

                // Award points when obstacle passes player
                if (obstacle.x + obstacle.width < player.x && !obstacle.passed && obstacle.type === 'ground') {
                    obstacle.passed = true;
                    score += 10;
                    scoreElement.textContent = score;
                }

                // Remove if far off screen
                if (obstacle.x + obstacle.width < -100) {
                    obstacles.splice(i, 1);
                }
            }
        }

        // Check collisions (AABB) - with more forgiving hitbox
        function checkCollision(rect1, rect2) {
            // Make the character's collision box smaller than the obstacle's
            const getCenterBox = (rect, isPlayer) => {
                const boxScale = isPlayer ? 0.48 : 0.7; // player smaller, obstacle a bit larger
                const w = rect.width * boxScale;
                const h = rect.height * boxScale;
                return {
                    x: rect.x + (rect.width - w) / 2,
                    y: rect.y + (rect.height - h) / 2,
                    width: w,
                    height: h
                };
            };
            const a = getCenterBox(rect1, true); // player
            const b = getCenterBox(rect2, false); // obstacle
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        // Check game over and collectibles
        function checkGameOver() {
            for (let obstacle of obstacles) {
                if (obstacle.type === 'ground' && !obstacle.hit) {
                    // Only check collision if player is close to ground (not high in air)
                    // This allows player to jump OVER obstacles without collision
                    const playerBottom = player.y + player.height;
                    const obstacleTop = obstacle.y;
                    
                    // Only collide if player's bottom is touching or below the top of obstacle
                    if (playerBottom > obstacleTop + 80 && checkCollision(player, obstacle)) {
                        // Hit ground obstacle - deduct 2 points
                        obstacle.hit = true;
                        score = Math.max(0, score - 2);
                        scoreElement.textContent = score;
                        
                        playSound('bomb');
                        
                        // Add subtle shake and red flash effect
                        canvas.classList.add('shake');
                        setTimeout(() => canvas.classList.remove('shake'), 200);
                        canvas.classList.add('red-border');
                        setTimeout(() => canvas.classList.remove('red-border'), 200);
                        
                        // Show floating point popup at obstacle center
                        showPointPopup(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, -2);
                        
                        // Mark obstacle for removal
                        obstacles = obstacles.filter(obs => obs !== obstacle);
                        return;
                    }
                } else if (obstacle.type === 'collectible' && !obstacle.collected) {
                    if (checkCollision(player, obstacle)) {
                        // Collected a point item (bone, arm, or bomb)
                        obstacle.collected = true;
                        collectedItems++;
                        const points = obstacle.pointValue;
                        score = Math.max(0, score + points);
                        scoreElement.textContent = score;
                        
                        // Play appropriate sound based on collectible type
                        if (obstacle.collectibleType === 'bomb') {
                            playSound('bomb');
                            // Add subtle shake and red flash effect
                            canvas.classList.add('shake');
                            setTimeout(() => canvas.classList.remove('shake'), 200);
                            canvas.classList.add('red-border');
                            setTimeout(() => canvas.classList.remove('red-border'), 200);
                        } else if (points < 0) {
                            playSound('wrongItem');
                        } else {
                            playSound('collect');
                        }
                        
                        // Show floating point popup at collectible center
                        showPointPopup(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, points);
                    }
                }
            }
        }

        // Draw player
        function drawPlayer() {
            const sprite = player.isJumping ? jumpingSprite : runningSprite;
            
            if (sprite.complete && sprite.naturalWidth > 0) {
                ctx.drawImage(sprite, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
        }

        // Draw obstacles
        function drawObstacles() {
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                if (obstacle.type === 'ground') {
                    const img = obstacleImages[obstacle.imageIndex];
                    if (img?.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    } else {
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    }
                } else if (!obstacle.collected) {
                    const img = collectibleImages[obstacle.collectibleType];
                    if (img?.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    } else {
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacle.y + obstacle.height / 2;
                        ctx.fillStyle = obstacle.collectibleType === 'bomb' ? '#333' : '#fff';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, obstacle.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        // Draw ground
        function drawGround(deltaTime, effectiveSpeed = gameSpeed) {
            // Draw floor image with scrolling animation
            if (floorImage.complete) {
                floorScrollOffset += effectiveSpeed;
                const floorWidth = floorImage.width;
                const floorHeight = canvas.height - groundY;
                
                if (floorScrollOffset >= floorWidth) floorScrollOffset = 0;
                
                ctx.drawImage(floorImage, -floorScrollOffset, groundY, floorWidth, floorHeight);
                ctx.drawImage(floorImage, floorWidth - floorScrollOffset, groundY, floorWidth, floorHeight);
            } else {
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            }
        }

        // Draw clouds (background)
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Game loop
        let frameCount = 0;
        function gameLoop(currentTime) {
            if (!gameRunning) return;

            const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;

            // Cap deltaTime to prevent spiral of death (max 0.1 seconds)
            const cappedDelta = Math.min(deltaTime, 0.1);

            // Calculate elapsed time
            const elapsed = (currentTime - gameStartTime) / 1000;

            // Update timer every 6 frames (10 times per second)
            if (frameCount % 6 === 0) {
                gameTimer = Math.max(0, GAME_DURATION - elapsed);
                const timeFormatted = Math.ceil(gameTimer).toString().padStart(2, '0');
                timeLeftElement.textContent = '00:' + timeFormatted;
                
                const timeDisplay = document.getElementById('timeDisplay');
                timeDisplay.style.background = gameTimer <= 5 ? '#ff6b6b' : '#1B4F91';
            }
            frameCount++;

            if (gameTimer <= 0) {
                playSound('completed');
                setTimeout(() => {
                    sounds.completed.pause();
                    sounds.completed.currentTime = 0;
                }, 2000);
                endGame();
                return;
            }

            // Speed boost for first 10 seconds (1.5x speed multiplier)
            const speedMultiplier = elapsed < 10 ? 1.5 : 1;
            const currentEffectiveSpeed = gameSpeed * speedMultiplier;

            // Update game with fixed timestep
            updatePlayer();
            updateObstacles(cappedDelta, currentEffectiveSpeed);
            checkGameOver();
            if (gameSpeed < maxSpeed) gameSpeed += speedIncrement;

            drawBackground();
            drawGround(cappedDelta, currentEffectiveSpeed);
            drawObstacles();
            drawPlayer();

            requestAnimationFrame(gameLoop);
        }

        // Show instruction screen from welcome
        function showInstructions() {
            welcomeScreen.style.display = 'none';
            instructionsScreen.style.display = 'flex';
        }

        // Start game
        async function startGame() {
            playSound('select');
            
            // Wait for assets to load if not ready
            if (!assetsReady) {
                countdownElement.textContent = 'Memuatkan...';
                countdownElement.style.display = 'block';
                countdownElement.style.animation = 'none';
                
                // Wait until assets are ready
                let attempts = 0;
                while (!assetsReady && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                countdownElement.style.display = 'none';
            }

            // Hide screens
            welcomeScreen.style.display = 'none';
            instructionsScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            // Reset game state
            score = 0;
            collectedItems = 0;
            gameSpeed = gameSettings.initialSpeed;
            maxSpeed = gameSettings.maxSpeed;
            obstacles = [];
            obstacleTimer = 0;
            obstacleInterval = gameSettings.obstacleInterval;
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.isJumping = false;
            scrollOffset = 0;
            floorScrollOffset = 0;
            gameTimer = GAME_DURATION;

            applySettingsToPlayer();

            scoreElement.textContent = score;
            timeLeftElement.textContent = GAME_DURATION;
            document.getElementById('timeDisplay').style.display = 'flex';
            document.getElementById('totalDisplay').style.display = 'flex';
            timeRemainingDiv.style.display = 'none';
            timeRemainingDiv.classList.remove('warning');
            
            // Show countdown
            await showCountdown(3);
            await showCountdown(2);
            await showCountdown(1);
            await showCountdown(0);
            
            // Stop countdown sound
            sounds.countdown.pause();
            sounds.countdown.currentTime = 0;
            
            // Start game
            gameRunning = true;
            lastTime = performance.now();
            gameStartTime = performance.now();
            playSound('background');
            requestAnimationFrame(gameLoop);
        }

        // End game
        function endGame() {
            gameRunning = false;
            sounds.background.pause();
            sounds.background.currentTime = 0;

            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                highScoreElement.textContent = highScore;
            }

            // Update score display
            document.getElementById('scoreNumber').textContent = score;
            
            // Change button text and background based on score
            const restartButton = document.getElementById('restartBtn');
            const scoreNumber = document.getElementById('scoreNumber');
            if (score < 50) {
                restartButton.textContent = 'MULA LAGI';
                // Show failed page
                gameOverScreen.style.backgroundImage = "url('assets/page/failed.webp')";
                // Hide score on failed page
                scoreNumber.style.display = 'none';
                // Keep button at original position for failed page
                restartButton.style.bottom = '150px';
            } else {
                restartButton.textContent = 'SELESAI';
                // Show score page (win)
                gameOverScreen.style.backgroundImage = "url('assets/page/score.webp')";
                // Show score on win page
                scoreNumber.style.display = 'block';
                // Move button up for score page
                restartButton.style.bottom = '480px';
            }
            
            gameOverScreen.style.display = 'flex';
            document.getElementById('timeDisplay').style.display = 'none';
            document.getElementById('totalDisplay').style.display = 'none';
            timeRemainingDiv.style.display = 'none';
        }

        // Event listeners
        welcomeBtn.addEventListener('click', () => { playSound('select'); showInstructions(); });
        restartBtn.addEventListener('click', () => {
            playSound('select');
            location.reload();
        });

        // Add hover-to-click functionality for all buttons (1 second hover)
        function addHoverClickToButton(button) {
            let hoverTimer = null;
            
            button.addEventListener('mouseenter', () => {
                hoverTimer = setTimeout(() => {
                    button.click();
                }, 1000);
            });
            
            button.addEventListener('mouseleave', () => {
                if (hoverTimer) {
                    clearTimeout(hoverTimer);
                    hoverTimer = null;
                }
            });
        }

        // Apply hover-to-click to all buttons
        const allButtons = [
            welcomeBtn, restartBtn
        ];
        
        allButtons.forEach(button => addHoverClickToButton(button));

        // Add hover-to-click for instruction text (1 second)
        const instructionText = document.getElementById('instructionText');
        let instructionHoverTimer = null;
        
        instructionText.addEventListener('mouseenter', () => {
            instructionHoverTimer = setTimeout(() => {
                instructionText.click();
            }, 1000);
        });
        
        instructionText.addEventListener('mouseleave', () => {
            if (instructionHoverTimer) {
                clearTimeout(instructionHoverTimer);
                instructionHoverTimer = null;
            }
        });

        // Keyboard support (optional - for testing)
        window.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            }
        });
    </script>
</body>
</html>
